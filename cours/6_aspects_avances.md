# Chapitre 6 : Aspects avanc√©s de Qt

## Objectifs p√©dagogiques

√Ä l'issue de ce chapitre, vous serez capable de :
- Ma√Ætriser l'architecture MDI (Multiple Document Interface) avec QMdiArea et QMdiSubWindow
- Utiliser les fonctions de trac√© avanc√©es pour cr√©er des graphiques personnalis√©s
- Impl√©menter des traitements asynchrones avec QRunnable et QThreadPool
- G√©rer les op√©rations sur le syst√®me de fichiers avec les classes Qt
- Internationaliser une application PyQt6 pour supporter plusieurs langues
- Cr√©er une application complexe combinant tous ces aspects

## Dur√©e estim√©e : 4h00
- **Th√©orie** : 2h00
- **Travaux pratiques** : 2h00

---

## 1. Architecture MDI (Multiple Document Interface)

### 1.1 Qu'est-ce que l'architecture MDI ?

L'architecture **MDI** permet de g√©rer plusieurs documents ou vues dans une seule fen√™tre principale. C'est l'approche utilis√©e par des applications comme Microsoft Word (versions anciennes), Photoshop, ou les IDE de d√©veloppement.

#### üè¢ **Concepts cl√©s**
- **QMdiArea** : Le conteneur principal qui g√®re toutes les sous-fen√™tres
- **QMdiSubWindow** : Une sous-fen√™tre individuelle contenant un widget
- **Document** : Le contenu r√©el de chaque sous-fen√™tre

#### ‚úÖ **Avantages de l'architecture MDI**
- Gestion centralis√©e de plusieurs documents
- Partage d'une barre de menu commune
- Navigation facile entre les documents
- Maximisation/minimisation ind√©pendante

### 1.2 Premier exemple MDI

Cr√©ons une application MDI basique pour comprendre les concepts :

```python
import sys
from typing import Optional
from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QMdiArea, QMdiSubWindow,
    QTextEdit, QMenuBar, QMenu, QVBoxLayout, QWidget
)

class MDIMainWindow(QMainWindow):
    """Fen√™tre principale avec architecture MDI"""
    
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Mon Application MDI")
        self.setGeometry(100, 100, 800, 600)
        
        # Cr√©er la zone MDI
        self.mdi_area = QMdiArea()
        self.setCentralWidget(self.mdi_area)
        
        # Configurer l'apparence
        self.mdi_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.mdi_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        self.setup_menu()
        self.setup_initial_documents()
    
    def setup_menu(self) -> None:
        """Configure le menu principal"""
        menubar = self.menuBar()
        
        # Menu Fichier
        file_menu = menubar.addMenu("Fichier")
        file_menu.addAction("Nouveau document", self.create_text_document)
        file_menu.addSeparator()
        file_menu.addAction("Quitter", self.close)
        
        # Menu Fen√™tre
        window_menu = menubar.addMenu("Fen√™tre")
        window_menu.addAction("Cascade", self.mdi_area.cascadeSubWindows)
        window_menu.addAction("Mosa√Øque", self.mdi_area.tileSubWindows)
        window_menu.addSeparator()
        window_menu.addAction("Fermer tout", self.mdi_area.closeAllSubWindows)
    
    def setup_initial_documents(self) -> None:
        """Cr√©e quelques documents d'exemple"""
        self.create_text_document("Document 1")
        self.create_text_document("Document 2")
        
        # Organiser en cascade
        self.mdi_area.cascadeSubWindows()
    
    def create_text_document(self, title: str = "Nouveau document") -> QMdiSubWindow:
        """Cr√©e un nouveau document texte"""
        # Cr√©er le widget de contenu
        text_edit = QTextEdit()
        text_edit.setPlainText(f"Contenu de {title}")
        
        # Cr√©er la sous-fen√™tre
        sub_window = QMdiSubWindow()
        sub_window.setWidget(text_edit)
        sub_window.setWindowTitle(title)
        sub_window.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose)
        
        # Ajouter √† la zone MDI
        self.mdi_area.addSubWindow(sub_window)
        sub_window.show()
        
        return sub_window

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MDIMainWindow()
    window.show()
    sys.exit(app.exec())
```

### 1.3 Strat√©gies de positionnement

QMdiArea propose plusieurs strat√©gies pour organiser les sous-fen√™tres :

```python
from PyQt6.QtWidgets import QMdiArea

class AdvancedMDIArea(QMdiArea):
    """Zone MDI avec strat√©gies de positionnement avanc√©es"""
    
    def __init__(self) -> None:
        super().__init__()
        self.setup_view_mode()
    
    def setup_view_mode(self) -> None:
        """Configure le mode d'affichage"""
        # Mode par d√©faut : fen√™tres libres
        self.setViewMode(QMdiArea.ViewMode.SubWindowView)
        
        # Alternative : mode onglets
        # self.setViewMode(QMdiArea.ViewMode.TabbedView)
    
    def arrange_cascade(self) -> None:
        """Organise les fen√™tres en cascade"""
        self.cascadeSubWindows()
    
    def arrange_tile(self) -> None:
        """Organise les fen√™tres en mosa√Øque"""
        self.tileSubWindows()
    
    def arrange_horizontal(self) -> None:
        """Organise les fen√™tres horizontalement"""
        sub_windows = self.subWindowList()
        if not sub_windows:
            return
        
        area_size = self.size()
        window_width = area_size.width() // len(sub_windows)
        
        for i, window in enumerate(sub_windows):
            window.resize(window_width, area_size.height())
            window.move(i * window_width, 0)
    
    def arrange_vertical(self) -> None:
        """Organise les fen√™tres verticalement"""
        sub_windows = self.subWindowList()
        if not sub_windows:
            return
        
        area_size = self.size()
        window_height = area_size.height() // len(sub_windows)
        
        for i, window in enumerate(sub_windows):
            window.resize(area_size.width(), window_height)
            window.move(0, i * window_height)
```

---

## 2. Fonctions de trac√© avanc√©es

### 2.1 QPainter et les primitives de dessin

Qt propose un syst√®me de dessin puissant avec **QPainter** pour cr√©er des graphiques personnalis√©s :

```python
from typing import Optional
from PyQt6.QtCore import QRectF, QPointF
from PyQt6.QtGui import QPainter, QPen, QBrush, QColor, QFont
from PyQt6.QtWidgets import QWidget

class WeatherChartWidget(QWidget):
    """Widget personnalis√© pour afficher un graphique m√©t√©o"""
    
    def __init__(self) -> None:
        super().__init__()
        self.setMinimumSize(400, 300)
        
        # Donn√©es d'exemple (temp√©rature par heure)
        self.temperatures: list[float] = [12.5, 13.2, 14.1, 15.8, 17.2, 18.5, 19.1, 18.8]
        self.hours: list[str] = ["8h", "9h", "10h", "11h", "12h", "13h", "14h", "15h"]
    
    def paintEvent(self, event) -> None:
        """Dessine le graphique de temp√©rature"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Pr√©parer la zone de dessin
        rect = self.rect()
        margin = 40
        chart_rect = QRectF(
            margin, margin,
            rect.width() - 2 * margin,
            rect.height() - 2 * margin
        )
        
        self.draw_background(painter, chart_rect)
        self.draw_axes(painter, chart_rect)
        self.draw_temperature_curve(painter, chart_rect)
        self.draw_labels(painter, chart_rect)
    
    def draw_background(self, painter: QPainter, chart_rect: QRectF) -> None:
        """Dessine le fond du graphique"""
        # Fond d√©grad√© bleu clair
        brush = QBrush(QColor(240, 248, 255))
        painter.fillRect(chart_rect, brush)
        
        # Bordure
        pen = QPen(QColor(100, 149, 237), 2)
        painter.setPen(pen)
        painter.drawRect(chart_rect)
    
    def draw_axes(self, painter: QPainter, chart_rect: QRectF) -> None:
        """Dessine les axes du graphique"""
        pen = QPen(QColor(128, 128, 128), 1)
        painter.setPen(pen)
        
        # Lignes de grille horizontales
        for i in range(5):
            y = chart_rect.top() + (i * chart_rect.height() / 4)
            painter.drawLine(
                chart_rect.left(), y,
                chart_rect.right(), y
            )
    
    def draw_temperature_curve(self, painter: QPainter, chart_rect: QRectF) -> None:
        """Dessine la courbe de temp√©rature"""
        if len(self.temperatures) < 2:
            return
        
        # Calculer les √©chelles
        min_temp = min(self.temperatures)
        max_temp = max(self.temperatures)
        temp_range = max_temp - min_temp or 1
        
        # Pr√©parer le pinceau pour la courbe
        pen = QPen(QColor(255, 69, 0), 3)
        painter.setPen(pen)
        
        # Dessiner la courbe point par point
        points: list[QPointF] = []
        for i, temp in enumerate(self.temperatures):
            x = chart_rect.left() + (i * chart_rect.width() / (len(self.temperatures) - 1))
            y = chart_rect.bottom() - ((temp - min_temp) / temp_range * chart_rect.height())
            points.append(QPointF(x, y))
        
        # Tracer les segments
        for i in range(len(points) - 1):
            painter.drawLine(points[i], points[i + 1])
        
        # Dessiner les points
        brush = QBrush(QColor(255, 69, 0))
        painter.setBrush(brush)
        for point in points:
            painter.drawEllipse(point, 4, 4)
    
    def draw_labels(self, painter: QPainter, chart_rect: QRectF) -> None:
        """Dessine les √©tiquettes"""
        font = QFont("Arial", 10)
        painter.setFont(font)
        painter.setPen(QColor(0, 0, 0))
        
        # Labels des heures
        for i, hour in enumerate(self.hours):
            x = chart_rect.left() + (i * chart_rect.width() / (len(self.hours) - 1))
            y = chart_rect.bottom() + 20
            painter.drawText(QPointF(x - 10, y), hour)
```

### 2.2 Primitives de dessin essentielles

**QPainter** offre toutes les primitives classiques :
- `drawRect()`, `drawEllipse()`, `drawLine()` - Formes de base
- `drawText()` - Texte avec police personnalis√©e
- `drawPolygon()` - Formes complexes
- `QPen` pour les contours, `QBrush` pour les remplissages

---

## 3. Programmation asynchrone avec les Threads

### 3.1 Pourquoi utiliser les Threads ?

Les **Threads** permettent d'ex√©cuter des t√¢ches longues sans bloquer l'interface utilisateur :

#### üö´ **Probl√®me sans Threads**
```python
# ‚ùå MAUVAIS : Bloque l'interface
def download_weather_data(self) -> None:
    for city in ["Paris", "Lyon", "Marseille"]:
        response = requests.get(f"https://api.weather.com/{city}")
        # L'interface est fig√©e pendant 3 secondes !
        time.sleep(1)  # Simulation de d√©lai r√©seau
```

#### ‚úÖ **Solution avec Threads**
```python
# ‚úÖ BON : Interface r√©active
def download_weather_data(self) -> None:
    worker = WeatherWorker(["Paris", "Lyon", "Marseille"])
    worker.signals.data_received.connect(self.update_display)
    self.thread_pool.start(worker)
    # L'interface reste r√©active !
```

### 3.2 Impl√©mentation avec QRunnable et QThreadPool

Cr√©ons un syst√®me de workers typ√© et robuste :

```python
from typing import Any, Callable
from PyQt6.QtCore import QObject, QRunnable, QThreadPool, pyqtSignal, pyqtSlot
import requests
import time

class WorkerSignals(QObject):
    """Signaux pour communiquer avec le thread principal"""
    
    # Signal √©mis quand des donn√©es sont re√ßues
    data_received = pyqtSignal(int, dict)  # (worker_id, data)
    
    # Signal √©mis en cas d'erreur
    error_occurred = pyqtSignal(int, str)  # (worker_id, error_message)
    
    # Signal √©mis quand le travail est termin√©
    finished = pyqtSignal(int)  # (worker_id,)

class WeatherWorker(QRunnable):
    """Worker pour t√©l√©charger les donn√©es m√©t√©o"""
    
    def __init__(self, worker_id: int, city: str) -> None:
        super().__init__()
        self.worker_id = worker_id
        self.city = city
        self.signals = WorkerSignals()
    
    @pyqtSlot()
    def run(self) -> None:
        """Ex√©cute le t√©l√©chargement des donn√©es"""
        try:
            # Simulation d'un appel API
            self.signals.data_received.emit(
                self.worker_id,
                {"city": self.city, "temp": 20.5, "humidity": 65}
            )
            
            # Simulation de d√©lai r√©seau
            time.sleep(1)
            
        except Exception as e:
            self.signals.error_occurred.emit(self.worker_id, str(e))
        finally:
            self.signals.finished.emit(self.worker_id)

class WeatherApp(QMainWindow):
    """Application m√©t√©o avec workers"""
    
    def __init__(self) -> None:
        super().__init__()
        self.thread_pool = QThreadPool()
        self.active_workers: set[int] = set()
        
        print(f"Threads maximum : {self.thread_pool.maxThreadCount()}")
    
    def download_weather_for_cities(self, cities: list[str]) -> None:
        """Lance le t√©l√©chargement pour plusieurs villes"""
        for worker_id, city in enumerate(cities):
            worker = WeatherWorker(worker_id, city)
            
            # Connecter les signaux
            worker.signals.data_received.connect(self.on_data_received)
            worker.signals.error_occurred.connect(self.on_error_occurred)
            worker.signals.finished.connect(self.on_worker_finished)
            
            # D√©marrer le worker
            self.active_workers.add(worker_id)
            self.thread_pool.start(worker)
    
    def on_data_received(self, worker_id: int, data: dict[str, Any]) -> None:
        """Traite les donn√©es re√ßues"""
        print(f"Worker {worker_id}: Donn√©es pour {data['city']}")
        # Mettre √† jour l'interface utilisateur ici
    
    def on_error_occurred(self, worker_id: int, error: str) -> None:
        """G√®re les erreurs"""
        print(f"Worker {worker_id}: Erreur - {error}")
    
    def on_worker_finished(self, worker_id: int) -> None:
        """Nettoie quand un worker se termine"""
        self.active_workers.discard(worker_id)
        print(f"Worker {worker_id} termin√©. Restants: {len(self.active_workers)}")
```

### 3.3 R√®gle essentielle

**üö® IMPORTANT** : Jamais modifier l'interface depuis un thread ! Toujours utiliser les signaux pour communiquer avec l'interface principale.

---

## 4. Gestion du syst√®me de fichiers

### 4.1 Dialogues de fichiers

Qt fournit des dialogues pr√™ts √† l'emploi pour s√©lectionner des fichiers :

```python
from PyQt6.QtWidgets import QFileDialog

# Ouvrir un fichier
file_path, _ = QFileDialog.getOpenFileName(
    self,
    "Ouvrir un fichier",
    "",
    "Fichiers texte (*.txt);;Tous les fichiers (*)"
)

# Sauvegarder un fichier
file_path, _ = QFileDialog.getSaveFileName(
    self,
    "Sauvegarder",
    "",
    "Fichiers JSON (*.json)"
)
```

### 4.2 Emplacements syst√®me

`QStandardPaths` permet d'acc√©der aux dossiers syst√®me standards :

```python
from PyQt6.QtCore import QStandardPaths

# Dossier Documents
docs_path = QStandardPaths.writableLocation(
    QStandardPaths.StandardLocation.DocumentsLocation
)

# Dossier de configuration de l'application
app_data = QStandardPaths.writableLocation(
    QStandardPaths.StandardLocation.AppDataLocation
)
```

---

## 5. Internationalisation (i18n)

### 5.1 Principe de base

Pour supporter plusieurs langues, marquez les textes avec `self.tr()` :

```python
from PyQt6.QtCore import QTranslator, QCoreApplication

class MyApp(QMainWindow):
    def __init__(self) -> None:
        super().__init__()
        self.translator = QTranslator()
        
        # Textes traduisibles
        self.setWindowTitle(self.tr("Mon Application"))
        button = QPushButton(self.tr("Cliquez ici"))
```

### 5.2 Processus de traduction

```bash
# 1. Extraire les cha√Ænes
pylupdate6 *.py -ts app_fr.ts

# 2. Traduire le fichier .ts avec un √©diteur

# 3. Compiler
lrelease app_fr.ts
```

### 5.3 Changer de langue

```python
def change_language(self, lang_code: str) -> None:
    if self.translator.load(f"app_{lang_code}.qm"):
        QCoreApplication.installTranslator(self.translator)
        # Mettre √† jour l'interface
        self.retranslate_ui()
```

---

## 6. Travaux pratiques

Les 4 TPs construisent progressivement une **application m√©t√©o MDI** compl√®te :

### üå§Ô∏è TP1 - Interface MDI m√©t√©o de base
**Dur√©e** : 30 minutes  
**Objectif** : Cr√©er l'architecture MDI avec diff√©rents types de documents

**√Ä r√©aliser** :
- Cr√©er une fen√™tre principale avec QMdiArea
- Impl√©menter 3 types de documents : "Vue actuelle", "Pr√©visions", "Graphiques"
- Ajouter un menu "Fen√™tre" avec options de disposition (cascade, mosa√Øque)
- Cr√©er des sous-fen√™tres avec contenu basique (QLabel avec texte d'exemple)

**Concepts abord√©s** : QMdiArea, QMdiSubWindow, gestion des menus

### üìä TP2 - Graphiques m√©t√©o personnalis√©s
**Dur√©e** : 30 minutes  
**Objectif** : Utiliser QPainter pour cr√©er des graphiques m√©t√©o

**√Ä r√©aliser** :
- Cr√©er un widget personnalis√© h√©ritant de QWidget
- Impl√©menter `paintEvent()` pour dessiner un graphique de temp√©ratures
- Ajouter ce widget dans une sous-fen√™tre MDI "Graphiques"
- Dessiner courbe, axes, grille et √©tiquettes

**Concepts abord√©s** : QPainter, dessin personnalis√©, int√©gration dans MDI

### üåê TP3 - T√©l√©chargement asynchrone de donn√©es
**Dur√©e** : 30 minutes  
**Objectif** : Impl√©menter des workers pour r√©cup√©rer des donn√©es m√©t√©o

**√Ä r√©aliser** :
- Cr√©er un `WeatherWorker` h√©ritant de `QRunnable`
- Impl√©menter le t√©l√©chargement simul√© de donn√©es pour plusieurs villes
- Connecter les signaux pour mettre √† jour l'interface
- Afficher les donn√©es dans une nouvelle sous-fen√™tre "Donn√©es temps r√©el"

**Concepts abord√©s** : QRunnable, QThreadPool, signaux inter-threads

### üåç TP4 - Internationalisation *(optionnel)*
**Dur√©e** : 30 minutes  
**Objectif** : Ajouter le support multilingue

**√Ä r√©aliser** :
- Marquer tous les textes avec `self.tr()`
- Cr√©er les fichiers de traduction (.ts) pour fran√ßais et anglais
- Ajouter un menu "Langue" pour changer la langue √† la vol√©e
- Tester le changement de langue en temps r√©el

**Concepts abord√©s** : QTranslator, processus de traduction, `tr()`

---

## 7. Points cl√©s √† retenir

### ‚úÖ Architecture MDI
- **QMdiArea** : Conteneur principal pour g√©rer plusieurs documents
- **QMdiSubWindow** : Chaque document dans sa propre sous-fen√™tre
- **Disposition** : cascade, mosa√Øque, ou arrangements personnalis√©s

### ‚úÖ Dessin personnalis√©
- **QPainter** : Outil principal pour le dessin
- **paintEvent()** : M√©thode √† surcharger pour dessiner
- **Antialiasing** : Am√©liore la qualit√© visuelle

### ‚úÖ Threads asynchrones
- **QRunnable** : Classe de base pour les t√¢ches asynchrones
- **QThreadPool** : Gestionnaire de pool de threads
- **Signaux** : Communication s√©curis√©e entre threads

### ‚úÖ Gestion des fichiers
- **QFileDialog** : Dialogues ouvrir/sauvegarder
- **QStandardPaths** : Emplacements syst√®me standards

### ‚úÖ Internationalisation
- **QTranslator** : Gestionnaire de traductions
- **tr()** : Marquer les cha√Ænes traduisibles
- **Processus** : lupdate ‚Üí traduire ‚Üí lrelease

---
