# Chapitre 5 : Architecture MVC (Model-View) en Qt

## Objectifs p√©dagogiques

√Ä l'issue de ce chapitre, vous serez capable de :
- Comprendre les concepts fondamentaux de l'architecture Model-View de Qt
- Distinguer les responsabilit√©s du mod√®le et de la vue dans une application Qt
- Impl√©menter des mod√®les personnalis√©s h√©ritant de QAbstractListModel et QAbstractTableModel
- Cr√©er des applications avec synchronisation automatique entre donn√©es et interface
- G√©rer les signaux de modification de mod√®les pour des mises √† jour en temps r√©el
- Impl√©menter la persistance de donn√©es dans une architecture Model-View
- Construire des interfaces complexes avec QListView

## Dur√©e estim√©e : 4h00
- **Th√©orie** : 2h00
- **Travaux pratiques** : 2h00

---

## 1. Comprendre l'architecture Model-View

### 1.1 Qu'est-ce que l'architecture Model-View ?

L'architecture **Model-View** est un patron de conception qui s√©pare les donn√©es de leur pr√©sentation. Elle divise une application en deux composants interconnect√©s mais distincts

#### üéØ **Le Mod√®le (Model)**
- **Responsabilit√©** : G√©rer les donn√©es et la logique m√©tier
- **Contient** : Les donn√©es brutes, leur structure et les r√®gles de validation
- **Exemple** : Une liste de t√¢ches, une base de donn√©es, un fichier JSON
- **Ind√©pendance** : Ne conna√Æt rien de l'interface utilisateur

#### üñºÔ∏è **La Vue (View)**  
- **Responsabilit√©** : Pr√©senter les donn√©es √† l'utilisateur
- **Contient** : Les widgets d'affichage et d'interaction
- **Exemple** : QListView, QTableView, QTreeView
- **Flexibilit√©** : Plusieurs vues peuvent partager le m√™me mod√®le

#### üé™ **O√π est pass√© le Controller ?**

**Question cruciale** : Dans le MVC traditionnel, on a trois composants distincts. Qu'est-il arriv√© au **Controller** dans Qt ?

**MVC traditionnel** :
- **Model** : G√®re les donn√©es et la logique m√©tier
- **View** : Affiche les donn√©es √† l'utilisateur  
- **Controller** : G√®re les interactions utilisateur et coordonne Model/View

**Qt Model-View** :
- **Model** : G√®re les donn√©es et la logique m√©tier (identique)
- **View** : Affiche les donn√©es ET g√®re les interactions utilisateur

**Pourquoi cette fusion ?** Dans Qt, les widgets de vue (QListView, QTableView) g√®rent naturellement :
- ‚úÖ **L'affichage** des donn√©es (r√¥le de Vue)
- ‚úÖ **Les interactions** clavier/souris (r√¥le de Contr√¥leur)
- ‚úÖ **La s√©lection** d'√©l√©ments (r√¥le de Contr√¥leur)
- ‚úÖ **L'√©dition** directe (r√¥le de Contr√¥leur)

**Le Controller existe toujours**, mais il est **int√©gr√© dans la View** ! C'est pourquoi Qt parle de **"Model-View"** plut√¥t que de **"Model-View-Controller"**.

### 1.2 Avantages de cette architecture

#### ‚úÖ **S√©paration des responsabilit√©s**
```python
# ‚ùå Approche na√Øve - tout m√©lang√©
class BadTodoApp:
    def __init__(self) -> None:
        self.todos = ["Acheter du lait", "Finir le projet"]  # Donn√©es
        self.list_widget = QListWidget()                     # Vue
        self.update_display()                                # Logique m√©lang√©e
    
    def add_todo(self, text: str) -> None:
        self.todos.append(text)           # Modification donn√©es
        item = QListWidgetItem(text)      # Mise √† jour vue
        self.list_widget.addItem(item)    # Logique m√©lang√©e !

# ‚úÖ Approche Model-View - s√©paration claire
class GoodTodoApp:
    def __init__(self) -> None:
        self.model = TodoModel()          # Mod√®le s√©par√©
        self.view = QListView()           # Vue s√©par√©e
        self.view.setModel(self.model)    # Connexion automatique
    
    def add_todo(self, text: str) -> None:
        self.model.add_todo(text)         # Seule modification du mod√®le
        # La vue se met √† jour automatiquement !
```

#### ‚úÖ **Synchronisation automatique**
- Les modifications du mod√®le d√©clenchent automatiquement les mises √† jour de la vue
- Plusieurs vues peuvent afficher les m√™mes donn√©es en temps r√©el
- Aucun code de synchronisation manuelle √† √©crire

#### ‚úÖ **R√©utilisabilit√© et flexibilit√©**
- Un m√™me mod√®le peut alimenter une QListView, une QTableView et une QTreeView
- Changement de vue sans modification du mod√®le
- Tests unitaires facilit√©s (mod√®le ind√©pendant de l'interface)

### 1.3 Premier exemple pratique

Pour illustrer la simplicit√© de l'architecture Model-View, commen√ßons par l'exemple le plus basique possible :

```python
import sys
from PyQt6.QtCore import QStringListModel
from PyQt6.QtWidgets import QApplication, QListView, QMainWindow

class SimpleListApp(QMainWindow):
    """Application basique avec une liste de textes"""
    
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Exemple Model-View simple")
        self.setGeometry(100, 100, 300, 400)
        
        # Donn√©es : simple liste de cha√Ænes
        fruits = ["Pomme", "Banane", "Orange", "Fraise", "Kiwi"]
        
        # Cr√©er le mod√®le avec les donn√©es
        self.model = QStringListModel(fruits)
        
        # Cr√©er la vue et la connecter au mod√®le
        self.list_view = QListView()
        self.list_view.setModel(self.model)  # üîë Connexion automatique !
        
        # D√©finir la vue comme widget central
        self.setCentralWidget(self.list_view)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = SimpleListApp()
    window.show()
    sys.exit(app.exec())
```

**üîë Points cl√©s de cet exemple :**
- **Simplicit√© maximale** : 3 lignes pour connecter mod√®le et vue
- **Aucune m√©thode √† surcharger** : `QStringListModel` g√®re tout automatiquement
- **S√©paration imm√©diate** : Les donn√©es sont dans le mod√®le, l'affichage dans la vue
- **Connexion magique** : `setModel()` √©tablit toute la communication automatiquement

---

## 2. Choisir et utiliser les mod√®les Qt

Qt propose plusieurs mod√®les pr√™ts √† l'emploi selon vos besoins. Choisir le bon mod√®le d√®s le d√©part vous fera gagner beaucoup de temps.

### 2.1 Les mod√®les disponibles dans Qt

| **Besoin** | **Mod√®le recommand√©** | **Quand l'utiliser** |
|------------|----------------------|---------------------|
| Liste simple de textes | `QStringListModel` | Affichage basique d'une liste de cha√Ænes |
| Liste complexe personnalis√©e | `QAbstractListModel` | Structures de donn√©es personnalis√©es |
| Tableau de donn√©es | `QAbstractTableModel` | Donn√©es en lignes/colonnes |
| Mod√®le polyvalent | `QStandardItemModel` | Prototypage rapide, donn√©es hi√©rarchiques |
| Fichiers/dossiers | `QFileSystemModel` | Explorer de fichiers |
| Base de donn√©es | `QSqlTableModel` | Acc√®s direct aux tables SQL |
| Structure d'arbre | `QAbstractItemModel` | Donn√©es hi√©rarchiques complexes |

**üéØ R√®gle g√©n√©rale** : Commencez toujours par le mod√®le le plus simple qui r√©pond √† vos besoins, puis √©voluez si n√©cessaire.

### 2.2 Exemple avanc√© : QAbstractListModel

Quand vous avez besoin de structures de donn√©es personnalis√©es, `QAbstractListModel` est votre alli√©. Cr√©ons une Todo List avec statut :

```python
from typing import Any
from PyQt6.QtCore import QAbstractListModel, QModelIndex, Qt
from typing_extensions import override

class TodoModel(QAbstractListModel):
    """Mod√®le pour g√©rer une liste de t√¢ches avec statut"""

    def __init__(self, todos: list[tuple[bool, str]] | None = None) -> None:
        super().__init__()
        # Structure : [(termin√©, texte), (termin√©, texte), ...]
        # o√π termin√© = True (fait) ou False (√† faire)
        self._todos = todos or []

    @override
    def columnCount(self, parent: QModelIndex | None = None) -> int:
        """üî¥ OBLIGATOIRE : Nombre d'√©l√©ments dans la liste"""
        return 1

    @override
    def rowCount(self, parent: QModelIndex | None = None) -> int:
        """üî¥ OBLIGATOIRE : Nombre de colonnes dans la liste"""
        return len(self._todos)

    @override
    def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any:
        """üî¥ OBLIGATOIRE : Donn√©es √† afficher pour un √©l√©ment"""
        if not index.isValid() or index.row() >= len(self._todos):
            return None

        is_done, text = self._todos[index.row()]

        if role == Qt.ItemDataRole.DisplayRole:
            # Texte √† afficher : pr√©fixe selon le statut
            prefix = "‚úÖ" if is_done else "üìù"
            return f"{prefix} {text}"

        return None

    def add_todo(self, text: str) -> None:
        """Ajoute une nouvelle t√¢che"""
        if not text.strip():
            return

        row = len(self._todos)
        
        # üö® CRUCIAL : Notifier AVANT modification
        self.beginInsertRows(QModelIndex(), row, row)
        
        # Modification des donn√©es
        self._todos.append((False, text.strip()))
        
        # üö® CRUCIAL : Notifier APR√àS modification
        self.endInsertRows()
        # ‚Üí La vue se met √† jour automatiquement !

    def toggle_done(self, row: int) -> None:
        """Bascule le statut d'une t√¢che"""
        if 0 <= row < len(self._todos):
            is_done, text = self._todos[row]
            self._todos[row] = (not is_done, text)
            
            # Notifier que cette ligne a chang√©
            index = self.index(row, 0)
            self.dataChanged.emit(index, index)

    def remove_todo(self, row: int) -> None:
        """Supprime une t√¢che"""
        if 0 <= row < len(self._todos):
            # üö® CRUCIAL : Notifier AVANT suppression
            self.beginRemoveRows(QModelIndex(), row, row)
            
            # Suppression des donn√©es
            del self._todos[row]
            
            # üö® CRUCIAL : Notifier APR√àS suppression
            self.endRemoveRows()
```

**üéØ M√©thodes obligatoires pour QAbstractListModel** :
- `rowCount()` : Indique combien d'√©l√©ments il y a
- `data()` : Fournit les donn√©es √† afficher pour chaque √©l√©ment

**üö® Signaux cruciaux** :
- `beginInsertRows()` / `endInsertRows()` : Pour les ajouts
- `beginRemoveRows()` / `endRemoveRows()` : Pour les suppressions  
- `dataChanged.emit()` : Pour les modifications

### 2.3 Connecter le mod√®le √† l'interface

Maintenant, cr√©ons une interface simple pour utiliser notre mod√®le :

```python
import sys
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QHBoxLayout,
    QWidget, QLineEdit, QPushButton, QListView
)

class TodoApp(QMainWindow):
    """Application Todo List compl√®te"""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Ma Todo List")
        self.setGeometry(100, 100, 400, 500)

        # Cr√©er le mod√®le avec quelques t√¢ches d'exemple
        initial_todos = [
            (False, "Acheter du lait"),
            (True, "Finir le projet"),
            (False, "Appeler maman")
        ]
        self.model = TodoModel(initial_todos)
        
        self.setup_ui()
        self.connect_signals()

    def setup_ui(self) -> None:
        """Configure l'interface utilisateur"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        layout = QVBoxLayout()
        central_widget.setLayout(layout)

        # Zone de saisie
        input_layout = QHBoxLayout()

        self.todo_input = QLineEdit()
        self.todo_input.setPlaceholderText("Nouvelle t√¢che...")
        input_layout.addWidget(self.todo_input)
        
        self.add_button = QPushButton("Ajouter")
        input_layout.addWidget(self.add_button)

        layout.addLayout(input_layout)

        # Liste des t√¢ches
        self.list_view = QListView()
        self.list_view.setModel(self.model)  # üîë Connexion magique !
        layout.addWidget(self.list_view)

        # Boutons d'action
        action_layout = QHBoxLayout()

        self.toggle_button = QPushButton("Basculer statut")
        action_layout.addWidget(self.toggle_button)

        self.delete_button = QPushButton("Supprimer")
        action_layout.addWidget(self.delete_button)

        layout.addLayout(action_layout)

    def connect_signals(self) -> None:
        """Connecte les signaux aux actions"""
        self.add_button.clicked.connect(self.add_todo)
        self.todo_input.returnPressed.connect(self.add_todo)  # Entr√©e pour ajouter
        self.toggle_button.clicked.connect(self.toggle_todo)
        self.delete_button.clicked.connect(self.delete_todo)

        self.list_view.doubleClicked.connect(self.toggle_todo)

    def add_todo(self) -> None:
        """Ajoute une nouvelle t√¢che"""
        text = self.todo_input.text()
        if text.strip():
            self.model.add_todo(text)
            self.todo_input.clear()
    
    def toggle_todo(self) -> None:
        """Bascule le statut de la t√¢che s√©lectionn√©e"""
        indexes = self.list_view.selectedIndexes()
        if indexes:
            row = indexes[0].row()
            self.model.toggle_done(row)

    def delete_todo(self) -> None:
        """Supprime la t√¢che s√©lectionn√©e"""
        indexes = self.list_view.selectedIndexes()
        if indexes:
            row = indexes[0].row()
            self.model.remove_todo(row)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = TodoApp()
    window.show()
    sys.exit(app.exec())
```

### 2.4 Enrichir l'affichage avec les r√¥les

La m√©thode `data()` peut retourner diff√©rents types d'informations selon le **r√¥le** demand√©. Am√©liorons notre Todo List :

```python
from PyQt6.QtGui import QColor, QFont
from PyQt6.QtCore import Qt

class EnhancedTodoModel(TodoModel):
    """Mod√®le Todo avec affichage enrichi"""
    
    @override
    def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any:
        """Donn√©es enrichies avec couleurs et formatage"""
        if not index.isValid() or index.row() >= len(self._todos):
            return None

        is_done, text = self._todos[index.row()]

        match role:
            case Qt.ItemDataRole.DisplayRole:
                # Texte √† afficher
                prefix = "‚úÖ" if is_done else "üìù"
                return f"{prefix} {text}"
            
            case Qt.ItemDataRole.ForegroundRole:
                # Couleur du texte
                return QColor(Qt.GlobalColor.green if is_done else Qt.GlobalColor.red)
            
            case Qt.ItemDataRole.FontRole:
                # Style de police
                font = QFont()
                if is_done:
                    font.setStrikeOut(True)  # Barr√© pour les t√¢ches termin√©es
                else:
                    font.setBold(True)  # Gras pour les t√¢ches √† faire
                return font
            
            case Qt.ItemDataRole.BackgroundRole:
                # Couleur de fond
                if is_done:
                    return QColor(240, 255, 240)  # Vert tr√®s clair
                return QColor(255, 250, 240)  # Jaune tr√®s clair
            
            case _:
                return None
```

**üé® R√¥les d'affichage principaux** :
- `DisplayRole` : Texte affich√©
- `ForegroundRole` : Couleur du texte
- `BackgroundRole` : Couleur de fond
- `FontRole` : Style de police (gras, italique, etc.)
- `DecorationRole` : Ic√¥ne √† afficher

### 2.5 Bonnes pratiques et conseils

#### Les erreurs √† √©viter absolument

#### ‚ùå **Oublier les signaux de notification**
```python
# ‚ùå ERREUR : Modification sans notification
def add_todo_wrong(self, text: str) -> None:
    self._todos.append((False, text))
    # La vue ne se met PAS √† jour !

# ‚úÖ CORRECT : Toujours notifier les changements
def add_todo_correct(self, text: str) -> None:
    row = len(self._todos)
    self.beginInsertRows(QModelIndex(), row, row)  # AVANT
    self._todos.append((False, text))              # MODIFICATION
    self.endInsertRows()                           # APR√àS
```

#### ‚ùå **M√©langer logique m√©tier et interface**
```python
# ‚ùå ERREUR : Logique dans l'interface
class BadTodoApp(QMainWindow):
    def add_todo(self) -> None:
        text = self.input.text()
        if len(text.strip()) == 0:  # Validation dans l'UI !
            return
        # Logique de sauvegarde dans l'UI !
        with open("todos.json", "w") as f:
            json.dump(self.todos, f)

# ‚úÖ CORRECT : Logique dans le mod√®le
class GoodTodoApp(QMainWindow):
    def add_todo(self) -> None:
        text = self.input.text()
        self.model.add_todo(text)  # Le mod√®le g√®re tout
```

#### Conseils pour bien d√©marrer

#### üéØ **Choisir le bon mod√®le**
1. **Liste de textes simples** ‚Üí `QStringListModel`
2. **Donn√©es personnalis√©es** ‚Üí `QAbstractListModel`
3. **Besoin de prototyper rapidement** ‚Üí `QStandardItemModel`
4. **En cas de doute** ‚Üí Commencez simple et √©voluez !

#### üîß **Structure de code recommand√©e**
```
my_app/
‚îú‚îÄ‚îÄ main.py              # Point d'entr√©e
‚îú‚îÄ‚îÄ assets/              # Ressources (images, ic√¥nes)
‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îî‚îÄ‚îÄ icons/
‚îú‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ domain/          # Logique m√©tier pure
    ‚îú‚îÄ‚îÄ models/          # Mod√®les Qt (QAbstractListModel, etc.)
    ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îî‚îÄ‚îÄ book_model.py
    ‚îú‚îÄ‚îÄ ui/
    ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îú‚îÄ‚îÄ forms/       # Fichiers Qt Designer (.ui)
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main_window.ui
    ‚îÇ   ‚îú‚îÄ‚îÄ views/       # Classes Python des vues
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ generated/           # Fichiers compil√©s depuis .ui
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main_window_ui.py
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main_window.py       # Classe finale avec logique
    ‚îÇ   ‚îú‚îÄ‚îÄ widgets/     # Widgets personnalis√©s
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ book_widget.py
    ‚îÇ   ‚îî‚îÄ‚îÄ styles/
    ‚îÇ       ‚îî‚îÄ‚îÄ app_style.qss        # Styles CSS/QSS
    ‚îî‚îÄ‚îÄ utils/
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îî‚îÄ‚îÄ persistence.py           # Sauvegarde/chargement
```

#### Conseils de performance

#### ‚ö° **Pour de gros volumes de donn√©es**
- Utilisez `beginResetModel()` / `endResetModel()` pour les changements massifs
- Groupez les modifications avec `dataChanged.emit(top_left, bottom_right)`
- √âvitez les calculs complexes dans `data()` - pr√©calculez si possible

---

## 3. Travaux pratiques

Les 4 TPs forment **une seule application** qui √©volue progressivement : un **gestionnaire de biblioth√®que personnelle**. Chaque TP ajoute des fonctionnalit√©s en suivant la progression du cours.

### üöß TP1 - Mod√®le de base et premi√®re vue
**Dur√©e** : 30 minutes  
**Objectif** : Cr√©er les fondations avec un mod√®le minimal

**√Ä r√©aliser** :
- Cr√©er un mod√®le `BookModel` h√©ritant de `QAbstractListModel`
- Impl√©menter les 2 m√©thodes obligatoires : `rowCount()` et `data()`
- Afficher une liste statique de 5 livres avec `QListView`
- Cr√©er l'interface de base avec `QMainWindow`

**Concepts abord√©s** : Architecture Model-View de base, m√©thodes obligatoires

### üöß TP2 - Interactions et signaux
**Dur√©e** : 30 minutes  
**Objectif** : Ajouter les interactions utilisateur de base

**√Ä r√©aliser** :
- Ajouter un `QLineEdit` et un bouton "Ajouter un livre"
- Impl√©menter `add_book()` avec les signaux `beginInsertRows()` / `endInsertRows()`
- Ajouter un bouton "Supprimer" pour le livre s√©lectionn√©
- Impl√©menter `remove_book()` avec les signaux `beginRemoveRows()` / `endRemoveRows()`

**Concepts abord√©s** : Signaux de modification, synchronisation automatique vue-mod√®le

### üöß TP3 - Enrichissement visuel avec les r√¥les
**Dur√©e** : 30 minutes
**Objectif** : Utiliser les r√¥les pour am√©liorer l'affichage

**√Ä r√©aliser** :
- √âtendre le mod√®le pour g√©rer auteur + statut (lu/non lu)
- Impl√©menter plusieurs r√¥les dans `data()` :
  - `DisplayRole` : "Titre par Auteur"
  - `ForegroundRole` : Couleur selon le statut
  - `FontRole` : Gras pour les livres non lus
  - `DecorationRole` : Ic√¥ne üìñ ou ‚úÖ
- Ajouter un bouton "Marquer comme lu"

**Concepts abord√©s** : R√¥les d'affichage, formatage conditionnel, `match/case`

### üöß TP4 - Persistance des donn√©es *(optionnel)*
**Dur√©e** : 30 minutes
**Objectif** : Sauvegarder et charger les donn√©es

**√Ä r√©aliser** :
- Impl√©menter `save_to_json()` pour sauvegarder la biblioth√®que
- Impl√©menter `load_from_json()` pour charger au d√©marrage
- Sauvegarder automatiquement √† chaque modification
- G√©rer les erreurs de fichier avec des try/except
- Ajouter un compteur "X livres dans votre biblioth√®que"

**Concepts abord√©s** : Persistance JSON, gestion d'erreurs, sauvegarde automatique

---

## 4. Points cl√©s √† retenir

### ‚úÖ Choisir le bon mod√®le
- **QStringListModel** : Pour les listes simples de textes
- **QAbstractListModel** : Pour les structures de donn√©es personnalis√©es
- **Autres** : Voir le livre pyqt6 pour les autres structures.
- **Principe** : Commencer simple et √©voluer selon les besoins

### ‚úÖ M√©thodes essentielles
- **`rowCount()`** : Nombre d'√©l√©ments (obligatoire)
- **`data()`** : Donn√©es √† afficher avec support des r√¥les (obligatoire)
- **Signaux** : `beginInsertRows()` / `endInsertRows()` pour les modifications

### ‚úÖ Architecture Model-View
- **S√©paration stricte** : Le mod√®le g√®re les donn√©es, la vue g√®re l'affichage
- **Connexion simple** : `view.setModel(model)` suffit pour tout connecter
- **Synchronisation automatique** : Pas de code de mise √† jour manuelle

### ‚úÖ Bonnes pratiques
- **Ne jamais oublier** les signaux de notification
- **S√©parer clairement** logique m√©tier et interface utilisateur
- **Structurer le code** en modules s√©par√©s (models/, views/, etc.)

---

## Prochaine √©tape

Dans le **Chapitre 6 - Aspects avanc√©s**, nous d√©couvrirons :
- Les d√©l√©gu√©s personnalis√©s pour l'√©dition avanc√©e de donn√©es
- L'int√©gration avec des bases de donn√©es via les mod√®les SQL de Qt
- Les techniques d'optimisation pour de gros volumes de donn√©es
- Les mod√®les proxy pour le filtrage et la transformation de donn√©es
